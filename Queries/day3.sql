-- Display all FIRST_NAME that has letter a in second character
--- '_a%'
SELECT FIRST_NAME
FROM EMPLOYEES
WHERE FIRST_NAME LIKE '_a%' ;


--each => group by VERY IMPORTANT

--FROM Departments Table
-- 1.13 Display Unique LOCATION_ID
select DISTINCT LOCATION_ID
FROM DEPARTMENTS;


--- FROM Locations Table
--- Count how many LOCATIONS we have
SELECT COUNT(*) FROM LOCATIONS;


-- 2.4 Display All Departments with DEPARTMENT_NAME Contains IT
--  exclude the exact match department name IT
-- CONTAINS == LIKE
SELECT * FROM DEPARTMENTS
WHERE DEPARTMENT_NAME LIKE '%IT %' ;


--3.4 Display the Employee Count for EACH FIRST_NAME (yeah and observe what you got)
--Filter the grouped result to only display if the count is more than 1

SELECT FIRST_NAME, COUNT(*)
FROM EMPLOYEES
GROUP BY FIRST_NAME
HAVING COUNT(*) > 1;



SELECT EMPLOYEES.FIRST_NAME
FROM EMPLOYEES ;

SELECT bla.FIRST_NAME
FROM EMPLOYEES bla;

------ SQL JOIN ------
--- IS USED TO GET DATA FROM 2 OR MORE TABLES THAT RELATED TO EACH OTEHR
-- PRIMARY KEY AND FOREIGN KEY RELATIONSHIP

--- INNER JOIN , LEFT OUTER JOIN , RIGHT OUTER JOIN , FULL OUTER JOIN

-- IN ORDER TO JOIN TWO TABLES THAT HAS RELATIONSHIP
-- SELECT DESIRED COLUMNS FROM BOTH TABLES
-- FROM TABLE 1
-- INNER JOIN TABLE 2 ON THE COMMON COLUMN


SELECT COUNTRIES.COUNTRY_NAME , REGIONS.REGION_NAME
FROM COUNTRIES
         INNER JOIN REGIONS ON COUNTRIES.REGION_ID = REGIONS.REGION_ID ;
-- we can use alias for table to make above query slightly more readable
-- nicknames are followed by space and the letter or word
-- you can use nickname to select the columns
-- just like you did in java obj.VariableName
SELECT c.COUNTRY_NAME , r.REGION_NAME
FROM COUNTRIES c
         INNER JOIN REGIONS r ON c.REGION_ID = r.REGION_ID ;



--- FIND OUT CITY (LOCATIONS) AND COUNTRY_NAME(COUNTRIES)
SELECT LOCATIONS.CITY, COUNTRIES.COUNTRY_NAME
FROM LOCATIONS
         INNER JOIN COUNTRIES ON LOCATIONS.COUNTRY_ID = COUNTRIES.COUNTRY_ID ;
;

SELECT l.CITY, c.COUNTRY_NAME
FROM LOCATIONS l
         INNER JOIN COUNTRIES c ON l.COUNTRY_ID = c.COUNTRY_ID ;
;
-- IT DOES NOT MATTER WHICH TABLE COMES FIRST
-- WHEN YOU DO INNER JOIN
SELECT l.CITY, c.COUNTRY_NAME
FROM COUNTRIES c
         INNER JOIN LOCATIONS l ON l.COUNTRY_ID = c.COUNTRY_ID ;


--DISPLAY DEPARTMENT_NAME (DEPARTMENTS) AND CITY (LOCATION)
SELECT DEPARTMENTS.DEPARTMENT_NAME, LOCATIONS.CITY
FROM DEPARTMENTS
         INNER JOIN LOCATIONS ON DEPARTMENTS.LOCATION_ID = LOCATIONS.LOCATION_ID ;


SELECT d.DEPARTMENT_NAME, l.CITY
FROM DEPARTMENTS d
         INNER JOIN LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID ;




--- DISPLAY FIRST_NAME (EMPLOYEES) , DEPARTMENT_NAME(DEPARTMENTS)
-- THEY ARE RELATED BY DEPARTMENT_ID


SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES
INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

--- INNER JOIN WILL RETURN THE DATA THAT MATCH FROM BOTH TABLE
--- IT'S RETURNING ONLY ROWS THAT HAS MATCHING DEPARTMENT_ID FROM BOTH TABLE
--- ANYTHING ELSE IS EXCLUDED
--- FOR EXAMPLE : KIMBERLY WITH NO DEPARTMENT ID
---               DEPARTMENTS WITH NO EMPLOYEES (MEANING NONE OF THE EMPLOYEES HAS THOSE DEPARTMENT_ID)
-- 106
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e
         INNER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;



-- WE WANT TO DISPLAY FIRST_NAME, DEPARTMENT_NAME
--- INCLUDING THOSE THAT DOES NOT HAVE MATCHING DEPARTMENT_ID
  --- LIKE KIMBERLY HAS NULL DEPARTMENT ID BUT WE STILL WANT TO GET THAT DATA
--- 106
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e
         LEFT OUTER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;;



--- -- WE WANT TO DISPLAY FIRST_NAME, DEPARTMENT_NAME
--- INCLUDING THOSE DEPARTMENTS THAT DOES NOT HAVE ANY MATCHING EMPLOYEES
--- 122
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e
         RIGHT OUTER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;



--- -- WE WANT TO DISPLAY FIRST_NAME, DEPARTMENT_NAME
--- INCLUDING THOSE THAT DOES NOT HAVE MATCHING DEPARTMENT_ID
--- INCLUDING THOSE DEPARTMENTS THAT DOES NOT HAVE ANY MATCHING EMPLOYEES
--- 123
SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
FROM EMPLOYEES e
         FULL OUTER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;



--- FACT : ALL DEPARTMENTS ARE LOCATED IN 7 DISTINCT CITY
--- FACT : THERE ARE 27 CITY IN LOCATIONS TABLE MEANING 16 OF THEM HAS NO DEPARTMENT

---  DISPLAY ALL DEPARTMENT_NAME (DEPARTMENTS) AND CITY(LOCATIONS)
--- INCLUDING THOSE CITY WITH NO DEPARTMENT IN IT
-- 43
SELECT d.DEPARTMENT_NAME , l.CITY
FROM DEPARTMENTS d
         RIGHT OUTER JOIN LOCATIONS l ON d.LOCATION_ID = l.LOCATION_ID ;









/*
--- HIGHLIGHT ALL AND RUN , IT WILL CREATE THE TABLE AND ADD DATA
--- TO PROGRAMS TABLE AND STUDENTS TABLE
CREATE TABLE PROGRAMS
(
    PROGRAM_ID   VARCHAR2(3)  NOT NULL,
    PROGRAM_NAME VARCHAR2(20) NOT NULL,
    DESCRIPTION  VARCHAR2(50),
    CONSTRAINT PROGRAMS_PK PRIMARY KEY (PROGRAM_ID) ENABLE
);
INSERT INTO PROGRAMS (PROGRAM_ID, PROGRAM_NAME, DESCRIPTION)
VALUES ('B15', 'B15 Online', 'B15 Online descriptions');
INSERT INTO PROGRAMS (PROGRAM_ID, PROGRAM_NAME, DESCRIPTION)
VALUES ('B17', 'B17 Local', 'B17 descriptions goes here');
INSERT INTO PROGRAMS (PROGRAM_ID, PROGRAM_NAME, DESCRIPTION)
VALUES ('B18', 'B18 Online', 'B18 description goes here');
INSERT INTO PROGRAMS (PROGRAM_ID, PROGRAM_NAME, DESCRIPTION)
VALUES ('B19', 'B19 Pending', 'B19 descriptions goes here');
CREATE TABLE STUDENTS
(
    STUDENT_ID   NUMBER            NOT NULL,
    STUDENT_NAME VARCHAR2(20 BYTE) NOT NULL,
    PROGRAM_ID   VARCHAR2(20 BYTE),
    CONSTRAINT STUDENTS_PK PRIMARY KEY (STUDENT_ID),
    CONSTRAINT STUDENTS_FK FOREIGN KEY (PROGRAM_ID)
        REFERENCES PROGRAMS (PROGRAM_ID),
    CONSTRAINT STUDENTS_UK UNIQUE (STUDENT_NAME),
    CONSTRAINT NAME_CHECK CHECK ( LENGTH(STUDENT_NAME) > 2 )
);
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (100, 'Johan', 'B18');
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (101, 'Adam', 'B17');
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (102, 'Mary', 'B17');
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (103, 'Anna', 'B15');
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (104, 'Jay', 'B18');
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (105, 'Mia', null);
INSERT INTO STUDENTS (student_id, student_name, program_id)
VALUES (106, 'Kory', null);

 */



--- DISPLAY FIRST_NAME AND JOB_TITLE
SELECT e.FIRST_NAME, j.JOB_TITLE
FROM EMPLOYEES e
         INNER JOIN JOBS j ON e.JOB_ID = j.JOB_ID ;


--- DISPLAY FIRST_NAME(EMPLOYEES)
--      AND JOB_TITLE(JOBS)
--      AND DEPARTMENT_NAME(DEPARTMENTS)

SELECT e.FIRST_NAME, j.JOB_TITLE, d.DEPARTMENT_NAME
FROM EMPLOYEES e
         INNER JOIN JOBS j ON e.JOB_ID = j.JOB_ID
         INNER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID ;




--- THIS IS THE NO ALIAS VERSION OF SAME QUERY
SELECT  EMPLOYEES.FIRST_NAME,
        JOBS.JOB_TITLE,
        DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES
         INNER JOIN JOBS        ON EMPLOYEES.JOB_ID = JOBS.JOB_ID
         INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID ;





---- DISPLAY CITY(LOCATIONS) , COUNTRY_NAME(COUNTRIES), REGION_NAME(REGIONS)
SELECT l.CITY , c.COUNTRY_NAME, r.REGION_NAME
FROM LOCATIONS l
         INNER JOIN COUNTRIES c ON l.COUNTRY_ID = c.COUNTRY_ID
         INNER JOIN REGIONS r ON c.REGION_ID = r.REGION_ID ;

---- SELECT e.FIRST_NAME, d.DEPARTMENT_NAME
SELECT d.DEPARTMENT_NAME , COUNT(e.FIRST_NAME)
FROM EMPLOYEES e
         INNER JOIN DEPARTMENTS d ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME ;

